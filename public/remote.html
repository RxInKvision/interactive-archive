<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Remote">
    <title>Remote Control - Neumorphic Fullscreen</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">

    <style>
        :root {
            --base-bg: #1A1C1E;
            --light-shadow-color: #25282B;
            --dark-shadow-color: #0F1113;
            --text-primary: #E0E2E5;
            --text-secondary: #A0A5AE;
            --text-tertiary: #6B7280;
            --accent-color: var(--text-primary);
            --neumorphic-blur: 10px;
            --neumorphic-distance: 5px;
            --neumorphic-radius-big: 22px;
            --neumorphic-radius-iphone: 55px;
            --neumorphic-radius-medium: 18px;
            --neumorphic-radius-small: 10px;
            --app-height: 100vh;
        }
        body, html {
            margin: 0; padding: 0; overflow: hidden;
            font-family: 'Source Code Pro', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: 300; background-color: var(--base-bg); color: var(--text-primary);
            display: flex; flex-direction: column; height: 100vh; height: var(--app-height);
            overscroll-behavior: none; position: relative;
        }
        .status-overlay {
            position: absolute; top: 0; z-index: 100; display: flex;
            align-items: center; padding: 30px; pointer-events: none;
        }
        .status-overlay > * { pointer-events: all; }
        #status-overlay-left {
            left: 0; font-size: 0.8em; color: var(--text-secondary);
            text-shadow: 1px 1px 2px var(--dark-shadow-color);
        }
        #status-overlay-right { right: 0; }
        #main-interaction-area {
            flex-grow: 1; display: flex; flex-direction: column;
            overflow: hidden; padding: 12px; padding-top: 0; gap: 12px;
            width: 100%; box-sizing: border-box;
        }
        #navigator-sphere-container {
            flex-shrink: 0; width: 100%; max-width: 90%; margin-left: auto; margin-right: auto;
            height: 85vw; max-height: 50vh; display: flex; justify-content: center; align-items: center;
            position: relative; background-color: var(--base-bg); border-radius: var(--neumorphic-radius-big);
            overflow: hidden; margin-top: 30px;
        }
        #cursor-rectangle {
            flex-grow: 1; flex-basis: 0; border-radius: var(--neumorphic-radius-iphone); background-color: var(--base-bg);
            display: flex; justify-content: center; align-items: center; text-align: center;
            color: var(--text-secondary); position: relative; -webkit-tap-highlight-color: transparent;
            touch-action: none; width: 100%;
            box-shadow: inset var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color),
                        inset calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color);
        }
        #sphere-touch-target {
            width: 70vmin; height: 70vmin; max-width: 85%; max-height: 85%; background: var(--base-bg);
            border-radius: 50%; display: flex; justify-content: center; align-items: center; text-align: center;
            -webkit-tap-highlight-color: transparent; touch-action: none; cursor: grab; position: relative;
            color: var(--text-secondary);
            box-shadow: var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color),
                        calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color);
            transition: box-shadow 0.15s ease-out, transform 0.1s ease-out;
        }
        #sphere-touch-target:active {
             box-shadow: inset var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color),
                         inset calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color);
            transform: scale(0.98);
        }
        #cursor-rectangle-text, #sphere-touch-target span {
            font-size: 1.0em; color: var(--text-secondary);
            text-shadow: 1px 1px 2px var(--dark-shadow-color), -1px -1px 2px var(--light-shadow-color);
            opacity: 0.9; transition: opacity 0.2s ease-out;
        }
        .virtual-cursor {
            position: absolute; width: 24px; height: 24px; background: white; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 10;
            mix-blend-mode: difference; box-shadow: none;
            transition: opacity 0.2s ease-out, transform 0.1s ease-out;
        }
        .status-dot { height: 10px; width: 10px; background-color: #e74c3c; border-radius: 50%; display: inline-block; margin-left: 8px; vertical-align: middle; box-shadow: 0 0 3px #e74c3c;}
        .status-dot.connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71;}
        .fullscreen-btn {
            background: var(--base-bg); border: none; color: var(--text-secondary);
            width: 30px; height: 30px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 16px;
            box-shadow: var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color),
                        calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color);
            transition: all 0.15s ease-out;
        }
        .fullscreen-btn:hover { color: var(--accent-color); }
        .fullscreen-btn:active {
            box-shadow: inset var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color),
                        inset calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color);
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="main-interaction-area">
        <div id="navigator-sphere-container">
            <div id="sphere-touch-target"><span>3D pad</span></div>
        </div>
        <div id="cursor-rectangle">
            <span id="cursor-rectangle-text">cursore</span>
        </div>
    </div>
    
    <div id="status-overlay-left" class="status-overlay">
        <span id="status-text">Initializing...</span>
        <span id="status-indicator" class="status-dot"></span>
    </div>
    <div id="status-overlay-right" class="status-overlay">
        <button class="fullscreen-btn" id="fullscreen-toggle" title="Toggle Fullscreen">â›¶</button> 
    </div>
    
    <div id="virtual-cursor-1" class="virtual-cursor"></div>
    <div id="virtual-cursor-2" class="virtual-cursor"></div>

    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <script>
        // --- INIZIO NUOVA SEZIONE ABLY ---
        const ABLY_API_KEY = '3GJyQg.xnTqzg:tt71NuL5l13occebb9fmAZa_rywbbwtklbpkjEFETQA';

        const ably = new Ably.Realtime({ key: ABLY_API_KEY });
        const channel = ably.channels.get('remote-control-channel'); // Nome del canale di comunicazione

        // Funzione per inviare dati al visore tramite Ably
        function sendToSocket(payload) {
            if (channel) {
                channel.publish('control-message', payload);
            }
        }
        // --- FINE NUOVA SEZIONE ABLY ---


        // Il resto del codice rimane quasi identico, usa la nuova funzione `sendToSocket`
        const cursorRectangle = document.getElementById('cursor-rectangle');
        const cursorRectangleText = document.getElementById('cursor-rectangle-text');
        const virtualCursor1 = document.getElementById('virtual-cursor-1');
        const virtualCursor2 = document.getElementById('virtual-cursor-2');
        const sphereTouchTarget = document.getElementById('sphere-touch-target');
        const sphereTouchTargetText = sphereTouchTarget.querySelector('span');
        const statusText = document.getElementById('status-text');
        const statusIndicator = document.getElementById('status-indicator');
        const fullscreenButton = document.getElementById('fullscreen-toggle');

        channel.on('attached', () => {
            statusText.textContent = 'Connected';
            statusIndicator.classList.add('connected');
            console.log("Connesso al canale Ably come controller.");
        });
        
        channel.on('failed', () => {
            statusText.textContent = 'Connection Failed';
            statusIndicator.classList.remove('connected');
        });

        channel.subscribe('feedback-message', (message) => {
            console.log("Feedback ricevuto:", message.data);
            if(message.data.type === 'hoverFeedback' && message.data.itemId) {
                triggerHapticFeedback(5);
            }
        });

        function triggerHapticFeedback(duration = 5) {
            if (navigator.vibrate) {
                try { navigator.vibrate(duration); } catch (e) { console.log("Haptic feedback failed.", e); }
            }
        }
        
        const availableLayouts = ["GRID", "RANDOM_3D", "SPHERE_SURFACE", "TUBE"];
        let currentLayoutSphereIndex = 0;
        
        const activeTouches_cursorPad = new Map(); 
        let pointerDownTime_cursorPad = 0, pointerDownPosition_cursorPad = { x: 0, y: 0 }, isDraggingForCursor_cursorPad = false;
        const TAP_MOVE_THRESHOLD_cursorPad = 10, TAP_TIME_THRESHOLD_cursorPad = 300; 
        
        const nav_activeTouches = new Map();
        let nav_pointerDownOnPad = false, nav_isOrbiting = false, nav_lastOrbitPos = { x: 0, y: 0 }, nav_isMultiTouching = false;
        let nav_touch1_navPad = null, nav_touch2_navPad = null, nav_lastPinchDist = 0, nav_lastCentroid_navPad = { x: 0, y: 0 };
        const NAV_ORBIT_SENSITIVITY_RAW = 1.5, NAV_DOLLY_SENSITIVITY_RAW = 0.004; 
        const NAV_PAN_SENSITIVITY_PIXELS = 0.8, NAV_ZOOM_SENSITIVITY_PIXELS = 0.1;
        const NAV_SPHERE_TAP_TIME_THRESHOLD = 250, NAV_SPHERE_TAP_MOVE_THRESHOLD = 15;
        let nav_pointerDownTime_sphere = 0, nav_pointerDownStartPos_sphere = { x: 0, y: 0 };
        
        function getCentroid(touchesMap) { let sx=0,sy=0,c=0;for(const t of touchesMap.values()){sx+=t.clientX;sy+=t.clientY;c++;} return(c>0)?{x:sx/c,y:sy/c}:{x:0,y:0};}
        function calculateDistance(p1,p2){if(!p1||!p2||typeof p1.clientX !=='number'||typeof p1.clientY !=='number'||typeof p2.clientX !=='number'||typeof p2.clientY !=='number'){return 0;}return Math.sqrt(Math.pow(p2.clientX-p1.clientX,2)+Math.pow(p2.clientY-p1.clientY,2));}
        function clampToCircle(x, y, circleElement) {
            const rect = circleElement.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const radius = rect.width / 2;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > radius) {
                const angle = Math.atan2(dy, dx);
                return {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            }
            return { x, y };
        }

        if (cursorRectangle) { 
            cursorRectangle.addEventListener('pointerdown', (e) => { 
                triggerHapticFeedback();
                e.preventDefault(); try { cursorRectangle.setPointerCapture(e.pointerId); } catch(err) {}
                activeTouches_cursorPad.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId });
                isDraggingForCursor_cursorPad = false;
                if (activeTouches_cursorPad.size === 1) {
                    pointerDownTime_cursorPad = Date.now();
                    pointerDownPosition_cursorPad = { x: e.clientX, y: e.clientY };
                    cursorRectangle.appendChild(virtualCursor1);
                    const rect = cursorRectangle.getBoundingClientRect();
                    virtualCursor1.style.left = `${e.clientX - rect.left}px`;
                    virtualCursor1.style.top = `${e.clientY - rect.top}px`;
                    virtualCursor1.style.display = 'block';
                    virtualCursor2.style.display = 'none';
                    if(cursorRectangleText) cursorRectangleText.style.opacity = '0';
                    sendToSocket({ type: 'pointerdown', x: (e.clientX - rect.left) / rect.width, y: (e.clientY - rect.top) / rect.height });
                } else if (activeTouches_cursorPad.size >= 2) {
                    virtualCursor1.style.display = 'none';
                    virtualCursor2.style.display = 'none';
                    sendToSocket({ type: 'pointerup' }); 
                }
            }, { passive: false });

            cursorRectangle.addEventListener('pointermove', (e) => {
                if (!activeTouches_cursorPad.has(e.pointerId)) return;
                e.preventDefault();
                activeTouches_cursorPad.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY, pointerId: e.pointerId });
                if (activeTouches_cursorPad.size === 1) {
                    const distMoved = Math.sqrt(Math.pow(e.clientX - pointerDownPosition_cursorPad.x, 2) + Math.pow(e.clientY - pointerDownPosition_cursorPad.y, 2));
                    if (distMoved > TAP_MOVE_THRESHOLD_cursorPad / 3) isDraggingForCursor_cursorPad = true;
                    const rect = cursorRectangle.getBoundingClientRect();
                    const normX = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                    const normY = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));
                    virtualCursor1.style.left = `${normX * rect.width}px`;
                    virtualCursor1.style.top = `${normY * rect.height}px`;
                    sendToSocket({ type: 'pointermove', x: normX, y: normY });
                }
            }, { passive: false });

            const handlePointerEndOrCancelCursorPad = (e) => {
                e.preventDefault();
                if (!activeTouches_cursorPad.has(e.pointerId)) return;
                activeTouches_cursorPad.delete(e.pointerId);
                try { cursorRectangle.releasePointerCapture(e.pointerId); } catch (err) {}
                if (activeTouches_cursorPad.size === 0) {
                    virtualCursor1.style.display = 'none';
                    virtualCursor2.style.display = 'none';
                    if(cursorRectangleText) cursorRectangleText.style.opacity = '0.9';
                    const timeHeld = Date.now() - pointerDownTime_cursorPad;
                    const distMoved = Math.sqrt(Math.pow(e.clientX - pointerDownPosition_cursorPad.x, 2) + Math.pow(e.clientY - pointerDownPosition_cursorPad.y, 2));
                    if (!isDraggingForCursor_cursorPad && timeHeld < TAP_TIME_THRESHOLD_cursorPad && distMoved < TAP_MOVE_THRESHOLD_cursorPad) {
                        triggerHapticFeedback(20);
                        sendToSocket({ type: 'click' });
                    }
                    sendToSocket({ type: 'pointerup' });
                    isDraggingForCursor_cursorPad = false;
                }
            };
            cursorRectangle.addEventListener('pointerup', handlePointerEndOrCancelCursorPad);
            cursorRectangle.addEventListener('pointercancel', handlePointerEndOrCancelCursorPad);
        }

        if (sphereTouchTarget) { 
            sphereTouchTarget.addEventListener('pointerdown', (e) => { 
                triggerHapticFeedback();
                e.preventDefault(); sphereTouchTarget.setPointerCapture(e.pointerId);
                nav_activeTouches.set(e.pointerId, { id: e.pointerId, clientX: e.clientX, clientY: e.clientY });
                nav_pointerDownOnPad = true;
                nav_pointerDownTime_sphere = Date.now();
                nav_pointerDownStartPos_sphere = { x: e.clientX, y: e.clientY };
                if (sphereTouchTargetText) sphereTouchTargetText.style.opacity = '0';
                const touchesArray = Array.from(nav_activeTouches.values());
                const rect = sphereTouchTarget.getBoundingClientRect();

                if (nav_activeTouches.size === 1) {
                    nav_isOrbiting = true;
                    nav_isMultiTouching = false;
                    nav_lastOrbitPos = { x: e.clientX, y: e.clientY };
                    sphereTouchTarget.appendChild(virtualCursor1);
                    const pos = clampToCircle(e.clientX - rect.left, e.clientY - rect.top, sphereTouchTarget);
                    virtualCursor1.style.left = `${pos.x}px`;
                    virtualCursor1.style.top = `${pos.y}px`;
                    virtualCursor1.style.display = 'block';
                    virtualCursor2.style.display = 'none';
                } else if (nav_activeTouches.size >= 2) {
                    nav_isOrbiting = false;
                    nav_isMultiTouching = true;
                    nav_touch1_navPad = touchesArray[0];
                    nav_touch2_navPad = touchesArray[1];
                    sphereTouchTarget.appendChild(virtualCursor1);
                    sphereTouchTarget.appendChild(virtualCursor2);
                    const pos1 = clampToCircle(nav_touch1_navPad.clientX - rect.left, nav_touch1_navPad.clientY - rect.top, sphereTouchTarget);
                    const pos2 = clampToCircle(nav_touch2_navPad.clientX - rect.left, nav_touch2_navPad.clientY - rect.top, sphereTouchTarget);
                    virtualCursor1.style.left = `${pos1.x}px`; virtualCursor1.style.top = `${pos1.y}px`;
                    virtualCursor2.style.left = `${pos2.x}px`; virtualCursor2.style.top = `${pos2.y}px`;
                    virtualCursor1.style.display = 'block'; virtualCursor2.style.display = 'block';
                    if (nav_touch1_navPad && nav_touch2_navPad) {
                        nav_lastPinchDist = calculateDistance(nav_touch1_navPad, nav_touch2_navPad);
                    }
                    nav_lastCentroid_navPad = getCentroid(nav_activeTouches);
                }
            });

            sphereTouchTarget.addEventListener('pointermove', (e) => {
                if (!nav_activeTouches.has(e.pointerId) || !nav_pointerDownOnPad) return;
                e.preventDefault();
                nav_activeTouches.set(e.pointerId, { id: e.pointerId, clientX: e.clientX, clientY: e.clientY });
                const rect = sphereTouchTarget.getBoundingClientRect();

                if (nav_activeTouches.size === 1 && nav_isOrbiting) {
                    const pos = clampToCircle(e.clientX - rect.left, e.clientY - rect.top, sphereTouchTarget);
                    virtualCursor1.style.left = `${pos.x}px`; virtualCursor1.style.top = `${pos.y}px`;
                    const dx = e.clientX - nav_lastOrbitPos.x;
                    const dy = e.clientY - nav_lastOrbitPos.y;
                    if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                        sendToSocket({ type: 'cameraCommand', command: 'orbit', dx: dx * NAV_ORBIT_SENSITIVITY_RAW, dy: dy * NAV_ORBIT_SENSITIVITY_RAW });
                        nav_lastOrbitPos = { x: e.clientX, y: e.clientY };
                    }
                } else if (nav_activeTouches.size >= 2 && nav_isMultiTouching) {
                    const currentT1 = nav_activeTouches.get(nav_touch1_navPad.id);
                    const currentT2 = nav_activeTouches.get(nav_touch2_navPad.id);
                    if (!currentT1 || !currentT2) return;
                    
                    const pos1 = clampToCircle(currentT1.clientX - rect.left, currentT1.clientY - rect.top, sphereTouchTarget);
                    const pos2 = clampToCircle(currentT2.clientX - rect.left, currentT2.clientY - rect.top, sphereTouchTarget);
                    virtualCursor1.style.left = `${pos1.x}px`; virtualCursor1.style.top = `${pos1.y}px`;
                    virtualCursor2.style.left = `${pos2.x}px`; virtualCursor2.style.top = `${pos2.y}px`;

                    const currentPinchDist = calculateDistance(currentT1, currentT2);
                    const currentCentroid = getCentroid(nav_activeTouches);
                    const pinchDelta = currentPinchDist - nav_lastPinchDist;
                    const panDx = currentCentroid.x - nav_lastCentroid_navPad.x;
                    const panDy = currentCentroid.y - nav_lastCentroid_navPad.y;

                    if (Math.abs(pinchDelta) > NAV_ZOOM_SENSITIVITY_PIXELS) {
                        sendToSocket({ type: 'cameraCommand', command: 'dolly', value: -pinchDelta * NAV_DOLLY_SENSITIVITY_RAW });
                    } else if (Math.abs(panDx) > NAV_PAN_SENSITIVITY_PIXELS || Math.abs(panDy) > NAV_PAN_SENSITIVITY_PIXELS) {
                        sendToSocket({ type: 'cameraCommand', command: 'pan', dx: panDx, dy: panDy });
                    }
                    nav_lastPinchDist = currentPinchDist;
                    nav_lastCentroid_navPad = currentCentroid;
                }
            });

            const navPointerEndHandler = (e) => {
                if (!nav_activeTouches.has(e.pointerId) && e.type !== 'pointerout') return;
                
                if (nav_activeTouches.has(e.pointerId) && nav_activeTouches.size === 1) {
                    const timeHeld = Date.now() - nav_pointerDownTime_sphere;
                    const distMoved = calculateDistance({clientX: e.clientX, clientY: e.clientY}, nav_pointerDownStartPos_sphere);
                    if (timeHeld < NAV_SPHERE_TAP_TIME_THRESHOLD && distMoved < NAV_SPHERE_TAP_MOVE_THRESHOLD) {
                        triggerHapticFeedback(20);
                        currentLayoutSphereIndex = (currentLayoutSphereIndex + 1) % availableLayouts.length;
                        sendToSocket({ type: 'appCommand', command: 'setLayout', value: availableLayouts[currentLayoutSphereIndex] });
                    }
                }
                
                if (nav_activeTouches.has(e.pointerId)) {
                    try { sphereTouchTarget.releasePointerCapture(e.pointerId); } catch(err) {}
                    nav_activeTouches.delete(e.pointerId);
                }

                virtualCursor1.style.display = 'none';
                virtualCursor2.style.display = 'none';
                if(sphereTouchTargetText) sphereTouchTargetText.style.opacity = '0.9';

                const touchesArray = Array.from(nav_activeTouches.values());
                if (touchesArray.length < 2) nav_isMultiTouching = false;
                if (touchesArray.length < 1) nav_isOrbiting = false;
            };
            sphereTouchTarget.addEventListener('pointerup', navPointerEndHandler);
            sphereTouchTarget.addEventListener('pointercancel', navPointerEndHandler);
            sphereTouchTarget.addEventListener('pointerout', (e) => {
                if (nav_activeTouches.has(e.pointerId) && (!e.buttons || e.buttons === 0) ) {
                    navPointerEndHandler(e);
                }
            });
        }
        
        function toggleFullScreen() {
             if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => console.log(err.message));
             } else {
                document.exitFullscreen();
             }
        }

        if (fullscreenButton) { 
            fullscreenButton.addEventListener('click', toggleFullScreen);
            fullscreenButton.addEventListener('pointerdown', () => triggerHapticFeedback(10));
        }

        const setAppHeight = () => { document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`); };
        window.addEventListener('resize', setAppHeight);
        window.addEventListener('orientationchange', setAppHeight);
        setAppHeight();

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        if (isIOS && fullscreenButton) { fullscreenButton.style.display = 'none'; }
        
        document.addEventListener('touchmove', function(event) { event.preventDefault(); }, { passive: false });
        window.addEventListener('contextmenu', function(e) { e.preventDefault(); });
    </script>
</body>
</html>