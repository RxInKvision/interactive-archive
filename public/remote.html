<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Remote Control</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
    <style>
        :root { --base-bg: #1A1C1E; --light-shadow-color: #25282B; --dark-shadow-color: #0F1113; --text-secondary: #A0A5AE; --neumorphic-blur: 10px; --neumorphic-distance: 5px; --neumorphic-radius-big: 22px; --neumorphic-radius-iphone: 55px; --app-height: 100vh; }
        *, *::before, *::after { box-sizing: border-box; }
        body, html { margin: 0; padding: 0; overflow: hidden; font-family: 'Source Code Pro', monospace; background-color: var(--base-bg); color: var(--text-primary); display: flex; flex-direction: column; height: 100vh; height: var(--app-height); overscroll-behavior: none; position: relative; }
        .status-overlay { position: absolute; top: 0; z-index: 100; display: flex; align-items: center; padding: 30px; pointer-events: none; }
        #status-overlay-left { left: 0; font-size: 0.8em; color: var(--text-secondary); text-shadow: 1px 1px 2px var(--dark-shadow-color); }
        #main-interaction-area { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; padding: 12px; padding-top: 0; gap: 12px; width: 100%; }
        #navigator-sphere-container { flex-shrink: 0; width: 100%; max-width: 90%; margin: 30px auto 0; height: 85vw; max-height: 50vh; display: flex; justify-content: center; align-items: center; position: relative; background-color: var(--base-bg); border-radius: var(--neumorphic-radius-big); overflow: hidden; }
        #cursor-rectangle, #sphere-touch-target { position: relative; -webkit-tap-highlight-color: transparent; touch-action: none; }
        #cursor-rectangle { flex-grow: 1; flex-basis: 0; border-radius: var(--neumorphic-radius-iphone); background-color: var(--base-bg); display: flex; justify-content: center; align-items: center; text-align: center; color: var(--text-secondary); width: 100%; box-shadow: inset var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color), inset calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color); }
        #sphere-touch-target { width: 70vmin; height: 70vmin; max-width: 85%; max-height: 85%; background: var(--base-bg); border-radius: 50%; display: flex; justify-content: center; align-items: center; text-align: center; cursor: grab; color: var(--text-secondary); box-shadow: var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color), calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color); transition: box-shadow 0.15s ease-out, transform 0.1s ease-out; }
        #sphere-touch-target:active { box-shadow: inset var(--neumorphic-distance) var(--neumorphic-distance) var(--neumorphic-blur) var(--dark-shadow-color), inset calc(-1 * var(--neumorphic-distance)) calc(-1 * var(--neumorphic-distance)) var(--neumorphic-blur) var(--light-shadow-color); transform: scale(0.98); }
        #cursor-rectangle-text, #sphere-touch-target span { font-size: 1.0em; color: var(--text-secondary); text-shadow: 1px 1px 2px var(--dark-shadow-color), -1px -1px 2px var(--light-shadow-color); opacity: 0.9; transition: opacity 0.2s ease-out; }
        .virtual-cursor { position: absolute; width: 24px; height: 24px; background: var(--base-bg); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 10; box-shadow: inset 2px 2px 4px var(--dark-shadow-color), inset -2px -2px 4px var(--light-shadow-color); transition: opacity 0.2s ease-out; }
        .status-dot { height: 10px; width: 10px; background-color: #e74c3c; border-radius: 50%; display: inline-block; margin-left: 8px; vertical-align: middle; box-shadow: 0 0 3px #e74c3c;}
        .status-dot.connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71;}
    </style>
</head>
<body>
    <div id="main-interaction-area">
        <div id="navigator-sphere-container">
            <div id="sphere-touch-target"><span>3D pad</span></div>
        </div>
        <div id="cursor-rectangle">
            <span id="cursor-rectangle-text">cursore</span>
        </div>
    </div>
    <div id="status-overlay-left" class="status-overlay">
        <span id="status-text">Initializing...</span>
        <span id="status-indicator" class="status-dot"></span>
    </div>
    <div id="virtual-cursor-1" class="virtual-cursor"></div>
    <div id="virtual-cursor-2" class="virtual-cursor"></div>

    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <script>
        // --- ABLY SETUP ---
        const ABLY_API_KEY = '3GJyQg.xnTqzg:tt71NuL5l13occebb9fmAZa_rywbbwtklbpkjEFETQA'; // Ricorda di rigenerarla!
        const ably = new Ably.Realtime(ABLY_API_KEY);
        const channel = ably.channels.get('remote-control-channel');

        function sendCommand(payload) {
            if (channel.state === 'attached') {
                channel.publish('control-message', payload);
            }
        }

        // --- DOM & STATE ---
        const statusText = document.getElementById('status-text');
        const statusIndicator = document.getElementById('status-indicator');
        const cursorPad = document.getElementById('cursor-rectangle');
        const spherePad = document.getElementById('sphere-touch-target');
        const virtualCursors = [document.getElementById('virtual-cursor-1'), document.getElementById('virtual-cursor-2')];
        const availableLayouts = ["GRID", "RANDOM_3D", "SPHERE_SURFACE", "TUBE"];
        let currentLayoutIndex = 0;

        let interactionState = {
            cursor: { isDown: false, isDragging: false, startTime: 0, startPos: { x: 0, y: 0 } },
            nav: { isDown: false, isDragging: false, touches: new Map(), lastCentroid: { x: 0, y: 0 }, lastPinchDist: 0, startTime: 0, startPos: {x:0, y:0} }
        };

        // --- ABLY CONNECTION LOGIC ---
        ably.connection.on('connected', () => { statusText.textContent = 'Connected'; statusIndicator.classList.add('connected'); });
        ably.connection.on('failed', () => { statusText.textContent = 'Connection Failed'; statusIndicator.classList.remove('connected'); });

        // --- UTILITY FUNCTIONS ---
        const getCentroid = (touches) => { let x=0, y=0; for(const t of touches.values()){ x+=t.clientX; y+=t.clientY; } return { x: x/touches.size, y: y/touches.size }; };
        const getDistance = (touches) => { if(touches.size < 2) return 0; const [t1,t2] = Array.from(touches.values()); return Math.hypot(t1.clientX-t2.clientX, t1.clientY-t2.clientY); };

        // --- CURSOR PAD EVENT HANDLERS ---
        if (cursorPad) {
            cursorPad.addEventListener('pointerdown', (e) => {
                e.preventDefault(); cursorPad.setPointerCapture(e.pointerId);
                Object.assign(interactionState.cursor, { isDown: true, isDragging: false, startTime: Date.now(), startPos: { x: e.clientX, y: e.clientY } });
                const rect = cursorPad.getBoundingClientRect();
                sendCommand({ type: 'pointerdown', x: (e.clientX-rect.left)/rect.width, y: (e.clientY-rect.top)/rect.height });
            });
            cursorPad.addEventListener('pointermove', (e) => {
                if (!interactionState.cursor.isDown) return;
                e.preventDefault();
                if (Math.hypot(e.clientX - interactionState.cursor.startPos.x, e.clientY - interactionState.cursor.startPos.y) > 10) {
                    interactionState.cursor.isDragging = true;
                }
                const rect = cursorPad.getBoundingClientRect();
                const normX = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                const normY = Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height));
                sendCommand({ type: 'pointermove', x: normX, y: normY });
            });
            const handleCursorUp = (e) => {
                if (!interactionState.cursor.isDown) return;
                e.preventDefault();
                if (!interactionState.cursor.isDragging && (Date.now() - interactionState.cursor.startTime < 300)) {
                    sendCommand({ type: 'click' });
                }
                sendCommand({ type: 'pointerup' });
                interactionState.cursor.isDown = false;
            };
            cursorPad.addEventListener('pointerup', handleCursorUp);
            cursorPad.addEventListener('pointercancel', handleCursorUp);
        }

        // --- SPHERE PAD EVENT HANDLERS ---
        if (spherePad) {
            spherePad.addEventListener('pointerdown', (e) => {
                e.preventDefault(); spherePad.setPointerCapture(e.pointerId);
                interactionState.nav.touches.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
                Object.assign(interactionState.nav, { isDown: true, isDragging: false, startTime: Date.now(), startPos: { x: e.clientX, y: e.clientY } });
                if (interactionState.nav.touches.size === 1) {
                    interactionState.nav.lastPos = { x: e.clientX, y: e.clientY };
                } else if (interactionState.nav.touches.size >= 2) {
                    interactionState.nav.lastCentroid = getCentroid(interactionState.nav.touches);
                    interactionState.nav.lastPinchDist = getDistance(interactionState.nav.touches);
                }
            });
            spherePad.addEventListener('pointermove', (e) => {
                if (!interactionState.nav.touches.has(e.pointerId)) return;
                e.preventDefault();
                interactionState.nav.touches.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
                if (Math.hypot(e.clientX - interactionState.nav.startPos.x, e.clientY - interactionState.nav.startPos.y) > 10) {
                    interactionState.nav.isDragging = true;
                }
                if (interactionState.nav.touches.size === 1) {
                    const dx = e.clientX - interactionState.nav.lastPos.x, dy = e.clientY - interactionState.nav.lastPos.y;
                    sendCommand({ type: 'cameraCommand', command: 'orbit', dx, dy });
                    interactionState.nav.lastPos = { x: e.clientX, y: e.clientY };
                } else if (interactionState.nav.touches.size >= 2) {
                    const centroid = getCentroid(interactionState.nav.touches), pinch = getDistance(interactionState.nav.touches);
                    const panDx = centroid.x - interactionState.nav.lastCentroid.x, panDy = centroid.y - interactionState.nav.lastCentroid.y;
                    const pinchDelta = pinch - interactionState.nav.lastPinchDist;
                    if (Math.abs(pinchDelta) > 0.5) sendCommand({ type: 'cameraCommand', command: 'dolly', value: -pinchDelta });
                    else if (Math.abs(panDx) > 0.5 || Math.abs(panDy) > 0.5) sendCommand({ type: 'cameraCommand', command: 'pan', dx: panDx, dy: panDy });
                    interactionState.nav.lastCentroid = centroid;
                    interactionState.nav.lastPinchDist = pinch;
                }
            });
            const handleNavUp = (e) => {
                if (!interactionState.nav.touches.has(e.pointerId)) return;
                e.preventDefault();
                if (!interactionState.nav.isDragging && (Date.now() - interactionState.nav.startTime < 250)) {
                    currentLayoutIndex = (currentLayoutIndex + 1) % availableLayouts.length;
                    sendCommand({ type: 'appCommand', command: 'setLayout', value: availableLayouts[currentLayoutIndex] });
                }
                interactionState.nav.touches.delete(e.pointerId);
                if (interactionState.nav.touches.size === 0) interactionState.nav.isDown = false;
            };
            spherePad.addEventListener('pointerup', handleNavUp);
            spherePad.addEventListener('pointercancel', handleNavUp);
        }

        // --- GENERAL SETUP ---
        const setAppHeight = () => document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);
        window.addEventListener('resize', setAppHeight); window.addEventListener('orientationchange', setAppHeight);
        setAppHeight();
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        window.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>